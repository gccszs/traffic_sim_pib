# 用户列表查询

<cite>
**本文档引用的文件**   
- [UserController.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/controller/UserController.java)
- [UserServiceImpl.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/service/UserServiceImpl.java)
- [UserServiceExt.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/service/UserServiceExt.java)
- [PageResult.java](file://traffic-sim-common/src/main/java/com/traffic/sim/common/response/PageResult.java)
- [UserDTO.java](file://traffic-sim-common/src/main/java/com/traffic/sim/common/dto/UserDTO.java)
- [AuthenticationInterceptor.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/interceptor/AuthenticationInterceptor.java)
- [PermissionInterceptor.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/interceptor/PermissionInterceptor.java)
- [plugin-user\README.md](file://plugins/plugin-user/README.md)
- [plugin-auth\README.md](file://plugins/plugin-auth/README.md)
</cite>

## 目录
1. [接口概述](#接口概述)
2. [请求参数说明](#请求参数说明)
3. [分页查询实现机制](#分页查询实现机制)
4. [响应结构说明](#响应结构说明)
5. [使用示例](#使用示例)
6. [认证与权限控制](#认证与权限控制)
7. [性能优化措施](#性能优化措施)

## 接口概述

`GET /api/user/list` 端点用于分页获取用户列表，支持可选的状态过滤功能。该接口是用户管理系统的核心查询接口，为前端提供高效、灵活的用户数据访问能力。

该接口通过 `UserController` 类中的 `getUserList` 方法实现，位于 `plugin-user` 模块中。接口设计遵循 RESTful 规范，采用统一的 API 响应格式，确保客户端能够一致地处理响应数据。

**Section sources**
- [UserController.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/controller/UserController.java#L107-L116)

## 请求参数说明

### HTTP方法与URL路径
- **HTTP方法**: `GET`
- **URL路径**: `/api/user/list`

### 分页参数
| 参数 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| page | int | 否 | 1 | 页码，从1开始计数 |
| size | int | 否 | 10 | 每页记录数，最大值受系统配置限制 |

### 可选过滤参数
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| status | String | 否 | 用户状态过滤，可选值：NORMAL（正常）、BANNED（已禁用）、BLOCKED（已锁定） |

**Section sources**
- [UserController.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/controller/UserController.java#L110-L112)
- [plugin-user\README.md](file://plugins/plugin-user/README.md#L132)

## 分页查询实现机制

用户列表的分页查询通过 Spring Data JPA 的分页功能实现。系统在 `UserServiceImpl` 类中实现了 `getUserList` 方法，该方法处理分页逻辑并执行数据库查询。

分页查询的实现步骤如下：
1. 将前端传入的页码（从1开始）转换为 JPA 所需的索引（从0开始）
2. 创建 `Pageable` 对象，指定分页参数和排序规则（按创建时间倒序）
3. 根据是否提供状态参数，调用相应的 Repository 方法
4. 将实体对象转换为 DTO 对象
5. 构建并返回 `PageResult` 响应对象

查询结果按用户创建时间倒序排列，确保最新的用户记录优先显示。

```mermaid
flowchart TD
Start([开始]) --> ValidateParams["验证分页参数"]
ValidateParams --> ConvertPage["转换页码索引<br/>(page-1)"]
ConvertPage --> CreatePageable["创建Pageable对象<br/>(含排序规则)"]
CreatePageable --> CheckStatus{"状态参数存在?"}
CheckStatus --> |是| QueryByStatus["按状态查询<br/>userRepository.findByStatus()"]
CheckStatus --> |否| QueryAll["查询所有用户<br/>userRepository.findAll()"]
QueryByStatus --> ConvertDTO["转换实体为DTO"]
QueryAll --> ConvertDTO
ConvertDTO --> BuildResult["构建PageResult对象"]
BuildResult --> ReturnResult["返回响应"]
ReturnResult --> End([结束])
```

**Diagram sources **
- [UserServiceImpl.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/service/UserServiceImpl.java#L299-L327)

**Section sources**
- [UserServiceImpl.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/service/UserServiceImpl.java#L299-L327)
- [UserRepository.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/repository/UserRepository.java#L38)

## 响应结构说明

接口返回统一的 `ApiResponse<PageResult<UserDTO>>` 结构，其中 `PageResult` 包含分页信息和用户数据列表。

### PageResult 响应结构
| 字段 | 类型 | 说明 |
|------|------|------|
| records | List<UserDTO> | 当前页的用户数据列表 |
| total | Long | 总记录数 |
| page | Integer | 当前页码 |
| size | Integer | 每页大小 |
| pages | Integer | 总页数（根据total和size计算） |

### UserDTO 数据结构
| 字段 | 类型 | 说明 |
|------|------|------|
| id | Long | 用户ID |
| username | String | 用户名 |
| email | String | 邮箱 |
| phoneNumber | String | 电话号码 |
| institution | String | 所属机构 |
| roleId | Integer | 角色ID |
| roleName | String | 角色名称 |
| status | String | 用户状态 |
| createTime | Date | 创建时间 |
| updateTime | Date | 更新时间 |

```mermaid
classDiagram
class PageResult~T~ {
+T[] records
+Long total
+Integer page
+Integer size
+Integer pages
+PageResult(T[], Long, Integer, Integer)
}
class UserDTO {
+Long id
+String username
+String email
+String phoneNumber
+String institution
+Integer roleId
+String roleName
+String status
+Date createTime
+Date updateTime
}
class ApiResponse~T~ {
+String res
+String msg
+T data
+Long timestamp
}
ApiResponse~PageResult~UserDTO~~ --> PageResult~UserDTO~ : "包含"
PageResult~UserDTO~ --> UserDTO : "包含"
```

**Diagram sources **
- [PageResult.java](file://traffic-sim-common/src/main/java/com/traffic/sim/common/response/PageResult.java#L16-L45)
- [UserDTO.java](file://traffic-sim-common/src/main/java/com/traffic/sim/common/dto/UserDTO.java#L13-L29)

**Section sources**
- [PageResult.java](file://traffic-sim-common/src/main/java/com/traffic/sim/common/response/PageResult.java#L16-L45)
- [UserDTO.java](file://traffic-sim-common/src/main/java/com/traffic/sim/common/dto/UserDTO.java#L13-L29)

## 使用示例

### cURL 命令示例

#### 获取第一页的10个用户（默认参数）
```bash
curl -X GET "http://localhost:8080/api/user/list" \
  -H "Authorization: Bearer your-jwt-token"
```

#### 获取第2页的20个用户
```bash
curl -X GET "http://localhost:8080/api/user/list?page=2&size=20" \
  -H "Authorization: Bearer your-jwt-token"
```

#### 获取正常状态的用户（每页15个）
```bash
curl -X GET "http://localhost:8080/api/user/list?status=NORMAL&size=15" \
  -H "Authorization: Bearer your-jwt-token"
```

#### 获取已禁用的用户
```bash
curl -X GET "http://localhost:8080/api/user/list?status=BANNED" \
  -H "Authorization: Bearer your-jwt-token"
```

### 典型请求/响应示例

#### 请求：获取正常状态用户（第1页，每页5个）
```
GET /api/user/list?page=1&size=5&status=NORMAL
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### 响应：成功返回用户列表
```json
{
  "res": "OK",
  "msg": "ok",
  "data": {
    "records": [
      {
        "id": 1,
        "username": "admin",
        "email": "admin@example.com",
        "phoneNumber": "13800138000",
        "institution": "Admin Institution",
        "roleId": 1,
        "roleName": "管理员",
        "status": "NORMAL",
        "createTime": "2024-01-01T10:00:00",
        "updateTime": "2024-01-01T10:00:00"
      },
      {
        "id": 3,
        "username": "user01",
        "email": "user01@example.com",
        "phoneNumber": "13800138001",
        "institution": "Example Institution",
        "roleId": 2,
        "roleName": "普通用户",
        "status": "NORMAL",
        "createTime": "2024-01-02T14:30:00",
        "updateTime": "2024-01-02T14:30:00"
      }
    ],
    "total": 15,
    "page": 1,
    "size": 5,
    "pages": 3
  },
  "timestamp": 1704067200000
}
```

#### 响应：空结果集
```json
{
  "res": "OK",
  "msg": "ok",
  "data": {
    "records": [],
    "total": 0,
    "page": 1,
    "size": 10,
    "pages": 0
  },
  "timestamp": 1704067200000
}
```

**Section sources**
- [UserController.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/controller/UserController.java#L107-L116)
- [ApiResponse.java](file://traffic-sim-common/src/main/java/com/traffic/sim/common/response/ApiResponse.java#L14-L85)

## 认证与权限控制

### 认证要求
该接口需要有效的 JWT 令牌进行认证。客户端必须在请求头中提供 `Authorization: Bearer <token>`。

认证流程由 `AuthenticationInterceptor` 拦截器处理：
1. 拦截所有 `/api/**` 路径的请求（排除登录、注册等公共接口）
2. 从请求头或参数中提取 JWT 令牌
3. 验证令牌的有效性和过期时间
4. 将用户信息存入请求上下文

### 权限控制策略
虽然 `getUserList` 接口本身没有直接的权限注解，但其所在的 `UserController` 类可能继承了类级别的权限控制。系统通过 `PermissionInterceptor` 实现细粒度的权限控制。

权限验证流程：
1. 检查方法级别和类级别的 `@RequirePermission` 和 `@RequireRole` 注解
2. 获取当前用户的角色和权限信息
3. 验证用户是否具有访问该接口所需的权限
4. 如果权限不足，返回 403 禁止访问响应

```mermaid
sequenceDiagram
participant Client as "客户端"
participant AuthInterceptor as "认证拦截器"
participant PermissionInterceptor as "权限拦截器"
participant UserService as "用户服务"
Client->>AuthInterceptor : 发送请求(Authorization头)
AuthInterceptor->>AuthInterceptor : 提取JWT令牌
AuthInterceptor->>AuthInterceptor : 验证令牌有效性
alt 令牌有效
AuthInterceptor->>PermissionInterceptor : 继续处理
PermissionInterceptor->>PermissionInterceptor : 检查权限注解
PermissionInterceptor->>PermissionInterceptor : 验证用户权限
alt 权限足够
PermissionInterceptor->>UserService : 继续处理
UserService->>UserService : 执行分页查询
UserService-->>Client : 返回用户列表
else 权限不足
PermissionInterceptor-->>Client : 403 禁止访问
end
else 令牌无效
AuthInterceptor-->>Client : 401 未授权
end
```

**Diagram sources **
- [AuthenticationInterceptor.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/interceptor/AuthenticationInterceptor.java#L26-L128)
- [PermissionInterceptor.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/interceptor/PermissionInterceptor.java#L27-L134)

**Section sources**
- [AuthenticationInterceptor.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/interceptor/AuthenticationInterceptor.java#L26-L128)
- [PermissionInterceptor.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/interceptor/PermissionInterceptor.java#L27-L134)
- [plugin-auth\README.md](file://plugins/plugin-auth/README.md#L123-L137)

## 性能优化措施

### 数据库查询优化
1. **索引优化**：在 `user` 表的 `status` 和 `create_time` 字段上创建索引，加速过滤和排序操作
2. **分页查询**：使用 JPA 的 `Pageable` 机制，避免一次性加载所有数据
3. **只读事务**：将查询操作标记为只读，允许数据库优化查询执行计划

### 缓存策略
1. **Redis缓存**：对于频繁访问的用户列表，可以考虑使用 Redis 缓存查询结果
2. **缓存键设计**：基于分页参数和过滤条件生成缓存键，如 `user_list:page_1:size_10:status_NORMAL`
3. **缓存失效**：当用户数据发生变化时（创建、更新、删除），清除相关缓存

### 响应时间预期
| 场景 | 预期响应时间 | 说明 |
|------|------------|------|
| 小数据集（<1000用户） | <100ms | 数据库查询和对象转换开销较小 |
| 中等数据集（1000-10000用户） | 100-300ms | 分页查询效率较高 |
| 大数据集（>10000用户） | 300-800ms | 受限于数据库查询性能 |
| 首次查询（无缓存） | 较高 | 包含数据库查询时间 |
| 后续查询（有缓存） | <50ms | 直接从缓存读取 |

对于大规模用户数据查询，建议：
1. 限制单页大小（如最大50条记录）
2. 实现缓存预热机制
3. 考虑使用 Elasticsearch 等搜索引擎替代数据库查询
4. 实现异步导出功能，避免阻塞API响应

**Section sources**
- [UserServiceImpl.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/service/UserServiceImpl.java#L299-L327)
- [UserRepository.java](file://plugins/plugin-user/src/main/java/com/traffic/sim/plugin/user/repository/UserRepository.java#L38)