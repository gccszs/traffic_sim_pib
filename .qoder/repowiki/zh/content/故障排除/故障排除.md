# 故障排除

<cite>
**本文档引用的文件**
- [plugin-auth-Issue.md](file://plugins/plugin-auth/plugin-auth-Issue.md)
- [plugin-map-Issue.md](file://plugins/plugin-map/plugin-map-Issue.md)
- [plugin-engine-manager-Issue.md](file://plugins/plugin-engine-manager/plugin-engine-manager-Issue.md)
- [plugin-engine-replay-Issue.md](file://plugins/plugin-engine-replay/plugin-engine-replay-Issue.md)
- [plugin-simulation-Issue.md](file://plugins/plugin-simulation/plugin-simulation-Issue.md)
- [plugin-statistics-Issue.md](file://plugins/plugin-statistics/plugin-statistics-Issue.md)
- [plugin-user-Issue.md](file://plugins/plugin-user/plugin-user-Issue.md)
- [traffic-sim-server-Issue.md](file://traffic-sim-server/traffic-sim-server-Issue.md)
- [application.yml](file://traffic-sim-server/src/main/resources/application.yml)
- [AuthServiceImpl.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/service/AuthServiceImpl.java)
- [PythonGrpcClient.java](file://plugins/plugin-map/src/main/java/com/traffic/sim/plugin/map/client/PythonGrpcClient.java)
- [EngineWebSocketHandler.java](file://plugins/plugin-engine-manager/src/main/java/com/traffic/sim/plugin/engine/manager/websocket/EngineWebSocketHandler.java)
</cite>

## 目录
1. [启动失败问题](#启动失败问题)
2. [gRPC通信故障](#grpc通信故障)
3. [认证失败问题](#认证失败问题)
4. [性能瓶颈与异步处理](#性能瓶颈与异步处理)
5. [插件配置与自动加载问题](#插件配置与自动加载问题)
6. [日志分析与调试技巧](#日志分析与调试技巧)

## 启动失败问题

### 端口占用问题

**症状描述**：
- 应用启动时抛出 `java.net.BindException: Address already in use` 异常
- 服务无法绑定到8080端口或其他配置端口
- 控制台输出显示端口已被其他进程占用

**根本原因分析**：
- `traffic-sim-server` 配置的默认端口为8080，可能被其他应用（如Tomcat、Nginx或其他Java应用）占用
- 数据库服务（MySQL、MongoDB、Redis）的默认端口也可能被占用
- 在开发环境中，可能有多个实例同时运行

**解决方案**：
1. **检查端口占用**：
   ```bash
   # Windows
   netstat -ano | findstr :8080
   # Linux/Mac
   lsof -i :8080
   ```
2. **终止占用进程**：
   ```bash
   # Windows (根据PID)
   taskkill /PID <PID> /F
   # Linux/Mac
   kill -9 <PID>
   ```
3. **修改应用端口**：在 `application.yml` 中修改server.port配置
   ```yaml
   server:
     port: 8081  # 修改为未被占用的端口
   ```
4. **使用Docker启动**：通过 `docker-compose.yml` 统一管理端口映射

**Section sources**
- [application.yml](file://traffic-sim-server/src/main/resources/application.yml#L48-L50)

### 数据库连接错误

**症状描述**：
- 启动时抛出 `Cannot connect to database` 或 `Access denied for user` 异常
- Hibernate无法初始化，显示数据库连接超时
- 应用启动失败，提示无法创建JPA EntityManager

**根本原因分析**：
- 数据库服务未启动或未正确配置
- 数据库连接URL、用户名或密码配置错误
- 数据库用户权限不足或数据库不存在
- 网络防火墙阻止了数据库端口访问

**解决方案**：
1. **启动数据库服务**：
   ```bash
   # 启动MongoDB
   ./start-mongodb.sh
   # 或使用Docker
   docker-compose -f docker-compose.mongodb.yml up -d
   ```
2. **验证数据库配置**：检查 `application.yml` 中的数据库配置
   ```yaml
   spring:
     datasource:
       url: jdbc:mysql://localhost:3306/traffic_sim?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
       username: root
       password: root
     data:
       mongodb:
         uri: mongodb://root:root@localhost:27017/traffic_sim?authSource=admin
   ```
3. **手动测试数据库连接**：
   ```bash
   # 测试MySQL连接
   mysql -h localhost -P 3306 -u root -p
   # 测试MongoDB连接
   mongo "mongodb://root:root@localhost:27017/traffic_sim"
   ```
4. **初始化数据库**：运行 `init.sql` 脚本创建必要的表结构

**Section sources**
- [application.yml](file://traffic-sim-server/src/main/resources/application.yml#L5-L40)
- [init.sql](file://infrastructure/init.sql)

## gRPC通信故障

### Python gRPC客户端未实现

**症状描述**：
- 地图上传后无法进行格式转换
- 系统返回 "gRPC client not implemented" 错误
- 日志中频繁出现 "gRPC client not implemented yet, using placeholder" 警告

**根本原因分析**：
- `plugin-map` 模块中的 `PythonGrpcClient` 仅包含TODO注释，未实现实际的gRPC调用逻辑
- `MapServiceImpl.uploadAndConvertMap()` 方法中调用Python服务转换文件的部分只有TODO注释
- 缺少Protocol Buffers定义文件（.proto）和相应的gRPC客户端实现

**解决方案**：
1. **参考已实现的gRPC客户端**：参考 `plugin-simulation` 模块的 `SimulationPythonGrpcClient` 实现
2. **定义Protocol Buffers文件**：创建 `python_service.proto` 文件定义服务接口
   ```proto
   syntax = "proto3";
   package com.traffic.sim.grpc;
   
   service PythonService {
     rpc UploadAndConvertFile(UploadRequest) returns (ConvertResponse);
   }
   
   message UploadRequest {
     bytes fileData = 1;
     string fileName = 2;
     string userId = 3;
   }
   
   message ConvertResponse {
     bool success = 1;
     string message = 2;
     bytes xmlData = 3;
     string xmlFileName = 4;
   }
   ```
3. **实现gRPC客户端**：在 `PythonGrpcClient` 中实现实际的gRPC调用
   ```java
   public ConvertFileResponse uploadAndConvertFile(MultipartFile file, String userId) {
       try {
           // 读取文件数据
           byte[] fileData = file.getBytes();
           
           // 构建gRPC请求
           UploadRequest request = UploadRequest.newBuilder()
               .setFileData(ByteString.copyFrom(fileData))
               .setFileName(file.getOriginalFilename())
               .setUserId(userId)
               .build();
           
           // 调用gRPC服务
           ConvertResponse response = pythonServiceStub.uploadAndConvertFile(request);
           
           // 处理响应
           ConvertFileResponse result = new ConvertFileResponse();
           result.setSuccess(response.getSuccess());
           result.setMessage(response.getMessage());
           result.setXmlData(response.getXmlData().toByteArray());
           result.setXmlFileName(response.getXmlFileName());
           
           return result;
       } catch (Exception e) {
           log.error("gRPC调用失败", e);
           ConvertFileResponse response = new ConvertFileResponse();
           response.setSuccess(false);
           response.setMessage("gRPC调用失败: " + e.getMessage());
           return response;
       }
   }
   ```
4. **配置gRPC客户端**：在 `application.yml` 中配置gRPC客户端参数
   ```yaml
   grpc:
     client:
       python-service:
         address: 'static://localhost:50051'
         negotiationType: plaintext
         enableKeepAlive: true
   ```

**Section sources**
- [plugin-map-Issue.md](file://plugins/plugin-map/plugin-map-Issue.md#L11-L41)
- [PythonGrpcClient.java](file://plugins/plugin-map/src/main/java/com/traffic/sim/plugin/map/client/PythonGrpcClient.java)
- [application.yml](file://traffic-sim-server/src/main/resources/application.yml#L68-L81)

## 认证失败问题

### 用户注册时密码传递问题

**症状描述**：
- 用户注册时系统提示成功，但无法使用注册的账号登录
- 数据库中用户记录的密码字段为空
- 认证服务无法验证用户密码

**根本原因分析**：
- `AuthServiceImpl.register()` 方法中创建用户时调用 `userService.createUser(userDTO)`
- `UserDTO` 不包含密码字段（这是正确的设计，因为DTO不应该包含敏感信息）
- 导致注册时无法传递密码给 `UserService`
- `plugin-user` 模块虽然提供了 `UserServiceExt.createUserWithPassword()` 方法，但 `plugin-auth` 未正确使用

**解决方案**：
1. **使用UserServiceExt接口**（推荐方案）：
   ```java
   @Service
   @RequiredArgsConstructor
   public class AuthServiceImpl implements AuthService {
       private final UserServiceExt userServiceExt; // 注入扩展接口
       
       @Override
       public void register(RegisterRequest request) {
           // 验证密码强度
           validatePasswordStrength(request.getPassword());
           
           // 检查用户名是否已存在
           UserDTO existingUser = userService.getUserByUsername(request.getUsername());
           if (existingUser != null) {
               throw new BusinessException(ErrorCode.ERR_EXIST, "用户名已存在");
           }
           
           // 创建用户创建请求
           UserCreateRequest createRequest = new UserCreateRequest();
           createRequest.setUsername(request.getUsername());
           createRequest.setPassword(request.getPassword());
           createRequest.setEmail(request.getEmail());
           createRequest.setPhoneNumber(request.getPhoneNumber());
           createRequest.setInstitution(request.getInstitution());
           createRequest.setStatus("ACTIVE");
           createRequest.setRoleId(1);
           createRequest.setRoleName("USER");
           
           // 使用扩展接口创建用户（包含密码）
           userServiceExt.createUserWithPassword(createRequest);
           
           log.info("用户注册成功: {}", request.getUsername());
       }
   }
   ```
2. **确保依赖注入**：在 `AuthServiceImpl` 的构造函数中注入 `UserServiceExt`
3. **更新依赖关系**：确保 `plugin-auth` 模块依赖 `plugin-user` 模块

**Section sources**
- [plugin-auth-Issue.md](file://plugins/plugin-auth/plugin-auth-Issue.md#L11-L53)
- [AuthServiceImpl.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/service/AuthServiceImpl.java#L93-L123)

### 令牌失效机制不完整

**症状描述**：
- 用户登出后，使用之前的refreshToken仍可获取新的accessToken
- 安全审计发现登出后令牌仍可使用
- refreshToken未被正确清理，存在安全漏洞

**根本原因分析**：
- `logout()` 方法中只将accessToken标记为失效
- 但没有清理对应的refreshToken
- 注释中提到"需要维护accessToken和refreshToken的映射关系"，但未实现
- `invalidatedTokens` 只存储了accessToken，没有处理refreshToken

**解决方案**：
1. **维护令牌映射关系**：在 `AuthServiceImpl` 中添加accessToken到refreshToken的映射
   ```java
   private final ConcurrentHashMap<String, String> tokenMapping = new ConcurrentHashMap<>();
   private final ConcurrentHashMap<String, TokenInfo> refreshTokenStore = new ConcurrentHashMap<>();
   
   @Override
   public LoginResponse login(LoginRequest request) {
       // ... 其他逻辑
       
       // 存储刷新令牌
       refreshTokenStore.put(refreshToken, tokenInfo);
       
       // 建立accessToken和refreshToken的映射关系
       tokenMapping.put(accessToken, refreshToken);
       
       // 构建响应
       LoginResponse response = new LoginResponse();
       response.setAccessToken(accessToken);
       response.setRefreshToken(refreshToken);
       // ...
       return response;
   }
   ```
2. **完善登出逻辑**：在 `logout()` 方法中同时清理两种令牌
   ```java
   @Override
   public void logout(String token) {
       if (token == null || token.isEmpty()) {
           return;
       }
       
       // 将令牌标记为失效
       invalidatedTokens.put(token, System.currentTimeMillis());
       
       // 解析令牌获取TokenInfo
       TokenInfo tokenInfo = jwtTokenService.parseToken(token);
       if (tokenInfo != null) {
           // 如果是accessToken，清理对应的refreshToken
           if (isAccessToken(token)) {
               String refreshToken = tokenMapping.get(token);
               if (refreshToken != null) {
                   refreshTokenStore.remove(refreshToken);
                   tokenMapping.remove(token);
               }
           } 
           // 如果是refreshToken，清理对应的accessToken映射
           else if (isRefreshToken(token)) {
               refreshTokenStore.remove(token);
               // 从反向映射中找到并清理accessToken
               tokenMapping.entrySet().removeIf(entry -> entry.getValue().equals(token));
           }
       }
       
       log.info("用户登出: {}", tokenInfo != null ? tokenInfo.getUsername() : "unknown");
   }
   ```

**Section sources**
- [plugin-auth-Issue.md](file://plugins/plugin-auth/plugin-auth-Issue.md#L57-L86)
- [AuthServiceImpl.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/service/AuthServiceImpl.java#L185-L201)

## 性能瓶颈与异步处理

### 统计服务异步处理配置

**症状描述**：
- 仿真数据处理时系统响应变慢
- WebSocket消息处理出现延迟
- 高并发场景下CPU使用率过高

**根本原因分析**：
- `StatisticsServiceImpl.processSimulationStep` 方法由于接口定义返回 `StatisticsData`（非 `Future`），无法直接使用 `@Async`
- 统计计算在主线程中同步执行，阻塞了WebSocket消息处理
- 虽然已配置独立的线程池 `statisticsExecutor`，但未在调用方使用

**解决方案**：
1. **在调用方使用异步处理**：在 `EngineWebSocketHandler` 中异步调用统计服务
   ```java
   @Async("statisticsExecutor")
   public CompletableFuture<StatisticsData> processSimulationDataAsync(Map<String, Object> simData) {
       try {
           StatisticsData statistics = statisticsService.processSimulationStep(simData);
           return CompletableFuture.completedFuture(statistics);
       } catch (Exception e) {
           log.warn("Statistics service failed", e);
           return CompletableFuture.completedFuture(null);
       }
   }
   ```
2. **更新WebSocket处理器**：修改 `processSimulationData` 方法使用异步调用
   ```java
   private void processSimulationData(String sessionId, WebSocketInfo wsMessage, SimInfo simInfo) {
       try {
           Map<String, Object> simData = wsMessage.getData();
           if (simData == null) {
               log.warn("Simulation data is null for session: {}", sessionId);
               return;
           }
           
           // 异步调用统计服务
           CompletableFuture<StatisticsData> future = processSimulationDataAsync(simData);
           
           future.thenAccept(statistics -> {
               // 在异步回调中处理结果
               WebSocketInfo statsMessage = new WebSocketInfo(
                   "frontend", 
                   "statistics", 
                   System.currentTimeMillis()
               );
               
               Map<String, Object> statsData = new HashMap<>();
               if (statistics != null) {
                   // ... 填充统计数据
               }
               statsMessage.setData(statsData);
               
               // 转发给前端
               if (simInfo != null && simInfo.isFrontendInitialized() && frontendWebSocketHandler != null) {
                   frontendWebSocketHandler.sendMessageToFrontend(sessionId, statsMessage);
               }
           }).exceptionally(throwable -> {
               log.error("Error processing simulation data", throwable);
               // 出错时转发原始数据
               if (simInfo != null && simInfo.isFrontendInitialized() && frontendWebSocketHandler != null) {
                   frontendWebSocketHandler.sendMessageToFrontend(sessionId, wsMessage);
               }
               return null;
           });
       } catch (Exception e) {
           log.error("Error processing simulation data for session: {}", sessionId, e);
           // 出错时转发原始数据
           if (simInfo != null && simInfo.isFrontendInitialized() && frontendWebSocketHandler != null) {
               frontendWebSocketHandler.sendMessageToFrontend(sessionId, wsMessage);
           }
       }
   }
   ```
3. **配置异步支持**：在Spring配置中启用异步支持
   ```java
   @Configuration
   @EnableAsync
   public class AsyncConfig {
       @Bean("statisticsExecutor")
       public Executor statisticsExecutor() {
           ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
           executor.setCorePoolSize(4);
           executor.setMaxPoolSize(8);
           executor.setQueueCapacity(100);
           executor.setThreadNamePrefix("statistics-");
           executor.setRejectedExecutionHandler(new ThreadPoolTaskExecutor.CallerRunsPolicy());
           executor.initialize();
           return executor;
       }
   }
   ```

**Section sources**
- [plugin-statistics-Issue.md](file://plugins/plugin-statistics/plugin-statistics-Issue.md#L87-L103)
- [EngineWebSocketHandler.java](file://plugins/plugin-engine-manager/src/main/java/com/traffic/sim/plugin/engine/manager/websocket/EngineWebSocketHandler.java#L107-L158)

## 插件配置与自动加载问题

### AutoConfiguration注解不一致

**症状描述**：
- 某些插件无法自动加载
- Spring Boot启动时未扫描到插件的组件
- 插件中的Controller、Service等Bean未注册到Spring容器

**根本原因分析**：
- 多个插件模块（`plugin-map`、`plugin-engine-manager`、`plugin-engine-replay`、`plugin-simulation`、`plugin-user`）使用 `@Configuration` 而不是 `@AutoConfiguration`
- 缺少 `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 文件
- Spring Boot 3.x的自动配置机制要求使用 `@AutoConfiguration` 和imports文件

**解决方案**：
1. **统一使用@AutoConfiguration注解**：将所有插件的配置类从 `@Configuration` 改为 `@AutoConfiguration`
   ```java
   // 修改前
   @Configuration
   @EnableConfigurationProperties(MapPluginProperties.class)
   public class MapPluginConfig {
   }
   
   // 修改后
   @AutoConfiguration
   @EnableConfigurationProperties(MapPluginProperties.class)
   public class MapPluginConfig {
   }
   ```
2. **创建AutoConfiguration.imports文件**：在每个插件的 `src/main/resources/META-INF/spring/` 目录下创建 `org.springframework.boot.autoconfigure.AutoConfiguration.imports` 文件
   ```
   com.traffic.sim.plugin.map.config.MapPluginConfig
   ```
3. **验证文件内容**：确保imports文件中包含配置类的全限定名
4. **检查依赖关系**：确保 `traffic-sim-server` 的pom.xml中已取消注释所有插件依赖

**Section sources**
- [plugin-map-Issue.md](file://plugins/plugin-map/plugin-map-Issue.md#L111-L133)
- [plugin-engine-manager-Issue.md](file://plugins/plugin-engine-manager/plugin-engine-manager-Issue.md#L71-L109)
- [plugin-engine-replay-Issue.md](file://plugins/plugin-engine-replay/plugin-engine-replay-Issue.md#L11-L31)
- [plugin-simulation-Issue.md](file://plugins/plugin-simulation/plugin-simulation-Issue.md#L44-L53)
- [plugin-user-Issue.md](file://plugins/plugin-user/plugin-user-Issue.md#L11-L34)

## 日志分析与调试技巧

### 关键日志分析

**认证相关日志**：
- **登录成功**：`用户登录成功: username`
- **登录失败**：`用户名或密码错误` 或 `验证码错误或已过期`
- **注册成功**：`用户注册成功: username`
- **令牌验证失败**：`Invalid JWT token` 或 `JWT token has expired`

**gRPC相关日志**：
- **客户端未实现**：`gRPC client not implemented yet, using placeholder`
- **连接失败**：`Failed to connect to python-service` 或 `gRPC call failed`
- **超时**：`gRPC call timed out after X ms`

**数据库相关日志**：
- **连接成功**：`HikariPool-1 - Starting...` 和 `HikariPool-1 - Start completed`
- **连接失败**：`Cannot connect to database` 或 `Access denied for user`
- **SQL执行**：`Executing statement` 和 `Result set fetched`

**WebSocket相关日志**：
- **连接建立**：`Engine WebSocket connected: session_id`
- **连接关闭**：`Engine WebSocket closed: session_id, status: ...`
- **消息处理**：`Error handling engine message` 或 `Failed to forward message`

### 调试命令

**检查服务状态**：
```bash
# 检查端口占用
netstat -tlnp | grep 8080
lsof -i :8080

# 检查Docker容器状态
docker ps -a
docker-compose ps

# 检查Java进程
jps -l
ps aux | grep java
```

**查看日志文件**：
```bash
# 实时查看应用日志
tail -f logs/traffic-sim-server.log

# 查看特定错误
grep -i "error" logs/traffic-sim-server.log
grep -i "exception" logs/traffic-sim-server.log
grep -i "warn" logs/traffic-sim-server.log

# 搜索特定模块日志
grep "plugin-auth" logs/traffic-sim-server.log
grep "gRPC" logs/traffic-sim-server.log
```

**调试gRPC服务**：
```bash
# 使用grpcurl测试gRPC服务
grpcurl -plaintext localhost:50051 list
grpcurl -plaintext localhost:50051 describe com.traffic.sim.grpc.PythonService

# 发送测试请求
grpcurl -plaintext -d '{"name": "test"}' localhost:50051 com.traffic.sim.grpc.PythonService/TestConnection
```

**数据库调试**：
```bash
# 连接MySQL
mysql -h localhost -P 3306 -u root -p
# 连接MongoDB
mongo "mongodb://root:root@localhost:27017/traffic_sim"

# 检查数据库状态
SHOW DATABASES;
USE traffic_sim;
SHOW TABLES;
SELECT * FROM user LIMIT 5;
```

**应用重启与验证**：
```bash
# 重启应用
mvn clean spring-boot:run

# 验证API端点
curl -X GET http://localhost:8080/api/actuator/health
curl -X GET http://localhost:8080/swagger-ui.html

# 测试登录
curl -X POST http://localhost:8080/api/login -H "Content-Type: application/json" -d '{"username":"admin","password":"password"}'
```

**Section sources**
- [application.yml](file://traffic-sim-server/src/main/resources/application.yml#L104-L117)
- [AuthServiceImpl.java](file://plugins/plugin-auth/src/main/java/com/traffic/sim/plugin/auth/service/AuthServiceImpl.java)
- [EngineWebSocketHandler.java](file://plugins/plugin-engine-manager/src/main/java/com/traffic/sim/plugin/engine/manager/websocket/EngineWebSocketHandler.java)