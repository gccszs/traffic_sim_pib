# 前端集成指南 - 新版两步流程

## 概述

为了解决前端无法提前获取 taskId 的问题，后端已将仿真创建流程拆分为两个步骤：

1. **准备阶段** (`/api/simulation/prepare`) - 生成 taskId 并创建 session
2. **启动阶段** (`/api/simulation/start`) - 启动仿真引擎

## 新版流程

### 步骤1: 准备仿真任务（获取 taskId）

**接口**: `POST /api/simulation/prepare`

**请求**: 无需请求体

**响应**:
```json
{
  "res": "ERR_OK",
  "msg": "Task prepared successfully",
  "data": "b2e2583144c04df1a5bdb9cf356c607b",
  "timestamp": 1769009390000
}
```

### 步骤2: 连接 WebSocket

使用步骤1返回的 taskId 连接 WebSocket。

**WebSocket URL**: `ws://localhost:3822/ws/frontend/{taskId}`

### 步骤3: 启动仿真引擎

**接口**: `POST /api/simulation/start?taskId={taskId}`

**请求体**:
```json
{
  "simInfo": {
    "name": "测试仿真",
    "mapId": "1",
    "mapXmlPath": "1/1.xml",
    "fixedOd": {
      // ... OD 数据
    }
  },
  "controlViews": []
}
```

**响应**:
```json
{
  "res": "ERR_OK",
  "msg": "Simulation started successfully",
  "data": "b2e2583144c04df1a5bdb9cf356c607b",
  "timestamp": 1769009392000
}
```

## 完整前端代码示例

```javascript
async function startSimulation(simulationConfig) {
  try {
    // ========== 步骤1: 准备仿真任务，获取 taskId ==========
    console.log('步骤1: 准备仿真任务...');
    const prepareResponse = await fetch('/api/simulation/prepare', {
      method: 'POST',
      credentials: 'include'  // 携带 Cookie
    });

    const prepareResult = await prepareResponse.json();
    
    if (prepareResult.res !== 'ERR_OK') {
      console.error('准备失败:', prepareResult.msg);
      return;
    }

    const taskId = prepareResult.data;
    console.log('✅ 获取到 taskId:', taskId);

    // ========== 步骤2: 连接 WebSocket ==========
    console.log('步骤2: 连接 WebSocket...');
    const ws = new WebSocket(`ws://localhost:3822/ws/frontend/${taskId}`);

    // 等待 WebSocket 连接成功
    await new Promise((resolve, reject) => {
      ws.onopen = () => {
        console.log('✅ WebSocket 连接成功');
        // 发送握手消息
        ws.send(JSON.stringify({
          type: 'backend',
          ope: 'hello',
          time: Date.now()
        }));
        resolve();
      };

      ws.onerror = (error) => {
        console.error('❌ WebSocket 连接失败:', error);
        reject(error);
      };

      // 设置超时
      setTimeout(() => reject(new Error('WebSocket 连接超时')), 5000);
    });

    // 设置消息处理
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      console.log('收到消息:', message);

      if (message.ope === 'hi') {
        console.log('✅ 收到后端握手响应');
      } else if (message.ope === 'eng_ok') {
        console.log('✅ 引擎已就绪');
      } else if (message.ope === 'simdata') {
        // 处理仿真数据
        handleSimulationData(message.data);
      } else if (message.ope === 'sim_end' || message.ope === 'finished') {
        console.log('✅ 仿真结束');
      }
    };

    ws.onclose = () => {
      console.log('WebSocket 连接关闭');
    };

    // ========== 步骤3: 启动仿真引擎 ==========
    console.log('步骤3: 启动仿真引擎...');
    const startResponse = await fetch(`/api/simulation/start?taskId=${taskId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        simInfo: simulationConfig,
        controlViews: []
      }),
      credentials: 'include'
    });

    const startResult = await startResponse.json();
    
    if (startResult.res !== 'ERR_OK') {
      console.error('启动失败:', startResult.msg);
      ws.close();
      return;
    }

    console.log('✅ 仿真引擎启动成功');
    
    // 返回 WebSocket 实例供后续使用
    return { taskId, ws };

  } catch (error) {
    console.error('启动仿真失败:', error);
    throw error;
  }
}

// 处理仿真数据
function handleSimulationData(data) {
  console.log('仿真数据:', data);
  // 更新UI，显示车辆、信号灯等
}

// 使用示例
const simulationConfig = {
  name: "测试仿真",
  mapId: "1",
  fixedOd: {
    // ... OD 配置
  }
};

startSimulation(simulationConfig).then(({ taskId, ws }) => {
  console.log('仿真已启动，taskId:', taskId);
  
  // 可以通过 ws 发送控制命令
  // 例如：开始仿真
  ws.send(JSON.stringify({
    type: 'eng',
    ope: 'start',
    time: Date.now()
  }));
});
```

## 时序图

```
前端                    后端                    引擎
 |                       |                       |
 |--1. POST /prepare---->|                       |
 |<----返回 taskId-------|                       |
 |                       |                       |
 |--2. 连接 WebSocket--->|                       |
 |<----握手成功----------|                       |
 |                       |                       |
 |--3. POST /start------>|                       |
 |                       |--启动引擎------------>|
 |                       |<----引擎连接 WS-------|
 |<----启动成功----------|                       |
 |                       |                       |
 |<---------仿真数据-------------------------|
 |                       |                       |
```

## 关键点

1. **必须按顺序执行三个步骤**：prepare → 连接 WebSocket → start
2. **taskId 在整个流程中保持一致**
3. **前端和引擎都使用同一个 taskId 连接 WebSocket**
4. **WebSocket 必须在调用 start 之前连接成功**

## 兼容性说明

旧的 `/api/simulation/create` 接口仍然可用，但已标记为 `@Deprecated`。建议使用新的两步流程以获得更好的控制。

## 错误处理

### 错误1: Session not found

**错误信息**: `Session not found. Please call /api/simulation/prepare first.`

**原因**: 调用 `/start` 时没有先调用 `/prepare`

**解决**: 确保先调用 `/prepare` 获取 taskId

### 错误2: WebSocket 连接失败

**原因**: taskId 不正确或 session 已过期

**解决**: 重新调用 `/prepare` 获取新的 taskId

### 错误3: 引擎启动失败

**原因**: 配置错误或引擎服务不可用

**解决**: 检查仿真配置和引擎服务状态

## 测试方法

### 使用 curl 测试

```bash
# 步骤1: 准备
TASK_ID=$(curl -X POST http://localhost:3822/api/simulation/prepare \
  -H "Cookie: id=test-user" \
  -s | jq -r '.data')

echo "TaskId: $TASK_ID"

# 步骤2: 连接 WebSocket（需要使用 WebSocket 客户端工具）

# 步骤3: 启动
curl -X POST "http://localhost:3822/api/simulation/start?taskId=$TASK_ID" \
  -H "Content-Type: application/json" \
  -H "Cookie: id=test-user" \
  -d '{
    "simInfo": {
      "name": "测试",
      "mapId": "1",
      "mapXmlPath": "1/1.xml",
      "fixedOd": {}
    },
    "controlViews": []
  }'
```

## 常见问题

**Q: 为什么要拆分成两步？**

A: 因为前端需要先获取 taskId 才能连接 WebSocket，而旧的流程中 taskId 是在引擎启动后才返回的，导致前端无法提前连接。

**Q: 可以不连接 WebSocket 直接调用 start 吗？**

A: 可以，但前端将无法接收仿真数据。建议先连接 WebSocket。

**Q: taskId 会过期吗？**

A: Session 有超时时间（默认30分钟），超时后需要重新调用 `/prepare`。

**Q: 可以同时创建多个仿真吗？**

A: 可以，每次调用 `/prepare` 都会生成新的 taskId，互不干扰。
